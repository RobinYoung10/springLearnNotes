# 关于IOC的理解

---

###什么是IOC

  IOC译为控制反转,是一个抽象概念.从一个简单的java例子来理解IOC更容易:

  传统模式下,我们调用一个服务接口,需要用new关键字声明它的实现类.比如一个支付接口,有一个外部而来的实现类:`Zhifu1`.在一个业务需求里面,需要用到`Zhifu1`类,于是在业务代码里会这样写:

```java
Zhifu zf = new Zhifu1();
```

并且在所有业务里面都是使用相同方式调用`Zhifu1`.那么问题来了,如果业务需求突然改变,或者因为某些原因,业务发生变动,实现类需要改变,需要改为使用另一个外部类`Pay1`,那我们需要找到每个调用接口的地方,并一一改正过来.这种传统模式下,把控制接口的权利交给业务代码,当业务需求改变时,需要将所有业务代码一一改变,低效且工作量大,这就是痛点所在.

  在IOC的理念里,同样一个例子,一个支付接口,一个外部实现类:`Zhifu1`,还会多出一样东西:一个IOC容器.IOC可以管理所有的java类,容纳我们开发或外部的各种Bean,我们可以从中获取各种发布在IOC里的Bean,并且通过描述得到它.以Spring为例,上面的业务中,我们把外部实现类`Zhifu1`在配置文件中声明:

```xml
<!--spring-config.xml-->
...
<bean id="ZhifuImpl" class="...Zhifu1">
...
```

然后在业务代码中通过spring上下文得到名为"ZhifuImpl"的类,并使用它,如果需要改变实现类,只需要在配置文件中将`class`改为对应的类即可,方便高效.

  这就是IOC控制反转的概念,简单来讲,就是将控制权从业务代码里面脱离出来,交给专门的容器,让他们来管理Bean.
